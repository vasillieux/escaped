import subprocess
import re
import os

from escaped.config import GITHUB_TOKEN 

# examples regexps are generated by AI, but seems to be valid.
# TODO create & test regexps for all corner cases

SOLIDITY_HEURISTICS = [
    {"name": "Hardcoded Private Key (Hex String in Solidity Context)", "regex": re.compile(r'(?:privateKey|deployerKey|ownerKey|adminKey)\s*[:=]\s*["\'](0x[a-fA-F0-9]{64})["\']', re.IGNORECASE), "severity": "CRITICAL", "type": "SOL_PK_HEX", "target_extensions": [".sol"]},
    {"name": "Mnemonic Phrase (Solidity Context)", "regex": re.compile(r'(?:mnemonic|seedPhrase)\s*[:=]\s*["\'](\w+\s+){11,23}\w+["\']', re.IGNORECASE), "severity": "CRITICAL", "type": "SOL_MNEMONIC", "target_extensions": [".sol"]},
    {"name": "delegatecall without guard (Basic)", "regex": re.compile(r'\.delegatecall\s*\(([^)]*)\);', re.IGNORECASE), "severity": "CRITICAL", "type": "SOL_DELEGATECALL_UNGUARDED", "target_extensions": [".sol"]},
    {"name": "selfdestruct usage", "regex": re.compile(r'selfdestruct\s*\(', re.IGNORECASE), "severity": "CRITICAL", "type": "SOL_SELFDESTRUCT", "target_extensions": [".sol"]},
    {"name": "tx.origin for Auth", "regex": re.compile(r'require\s*\(\s*msg\.sender\s*==\s*tx\.origin\s*\)', re.IGNORECASE), "severity": "CRITICAL", "type": "SOL_TX_ORIGIN_AUTH", "target_extensions": [".sol"]},
    {"name": "Reentrancy via .call{value}", "regex": re.compile(r'\w+\.call\s*\{value:\s*\w+\s*\}\s*\(\s*""\s*\)', re.IGNORECASE), "severity": "HIGH", "type": "SOL_REENTRANCY_CALL_VALUE", "target_extensions": [".sol"]},
    {"name": "Timestamp Dependence", "regex": re.compile(r'block\.timestamp', re.IGNORECASE), "severity": "HIGH", "type": "SOL_TIMESTAMP_DEPENDENCE", "target_extensions": [".sol"]},
    {"name": "Unchecked external call return value (Basic)", "regex": re.compile(r'^\s*(address\([\w\.]+\))\.call\(.*\);', re.MULTILINE | re.IGNORECASE), "severity": "HIGH", "type": "SOL_UNCHECKED_CALL_RETURN", "target_extensions": [".sol"]},
    {"name": "Assembly Usage (Basic)", "regex": re.compile(r'assembly\s*\{', re.IGNORECASE), "severity": "HIGH", "type": "SOL_ASSEMBLY_USAGE", "target_extensions": [".sol"]},
    {"name": "ecrecover Usage", "regex": re.compile(r'ecrecover\s*\(', re.IGNORECASE), "severity": "HIGH", "type": "SOL_ECRECOVER_USAGE", "target_extensions": [".sol"]},
    {"name": "TODO/FIXME/XXX Comments in Solidity", "regex": re.compile(r'//\s*(TODO|FIXME|XXX|HACK)', re.IGNORECASE), "severity": "MEDIUM", "type": "SOL_DEV_COMMENT_TODO", "target_extensions": [".sol"]},
    {"name": "abi.encodePacked Usage", "regex": re.compile(r'abi\.encodePacked\s*\(', re.IGNORECASE), "severity": "MEDIUM", "type": "SOL_ABI_ENCODEPACKED", "target_extensions": [".sol"]},
    {"name": "Hardcoded Address (Non-Zero in Solidity)", "regex": re.compile(r'=\s*(0x[a-fA-F0-9]{40})(?!\s*;\s*\/\/\s*zero address)', re.IGNORECASE), "severity": "MEDIUM", "type": "SOL_HARDCODED_ADDRESS", "target_extensions": [".sol"]},
    {"name": "Oracle Keyword (Solidity Context)", "regex": re.compile(r'oracle|priceFeed|getPrice|latestAnswer|latestRoundData', re.IGNORECASE), "severity": "MEDIUM", "type": "SOL_ORACLE_KEYWORD", "target_extensions": [".sol"]},
    {"name": "Flash Loan Keyword (Solidity Context)", "regex": re.compile(r'flashLoan|flashMint|onFlashLoan', re.IGNORECASE), "severity": "MEDIUM", "type": "SOL_FLASHLOAN_KEYWORD", "target_extensions": [".sol"]},
]

GENERAL_WEB3_HEURISTICS = [
    {"name": "Generic Private Key (Hex String)", "regex": re.compile(r'["\']?(0x[a-fA-F0-9]{64})["\']?'), "severity": "CRITICAL", "type": "GEN_PK_HEX"},
    {"name": "Generic Mnemonic Phrase", "regex": re.compile(r'["\']?(\w+\s+){11,23}\w+["\']?'), "severity": "CRITICAL", "type": "GEN_MNEMONIC"},
    {"name": "AWS Access Key ID", "regex": re.compile(r'AKIA[0-9A-Z]{16}'), "severity": "CRITICAL", "type": "AWS_ACCESS_KEY_ID"},
    {"name": "AWS Secret Access Key", "regex": re.compile(r'(?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{40}(?![A-Za-z0-9/+=])'), "severity": "CRITICAL", "type": "AWS_SECRET_ACCESS_KEY"},
    {"name": "Google Cloud API Key", "regex": re.compile(r'AIza[0-9A-Za-z\\-_]{35}'), "severity": "CRITICAL", "type": "GCP_API_KEY"},
    {"name": "GitHub Token", "regex": re.compile(r'ghp_[0-9a-zA-Z]{36}|github_pat_[0-9a-zA-Z_]{82}'), "severity": "CRITICAL", "type": "GITHUB_TOKEN"},

    {"name": "Infura Project ID/Secret", "regex": re.compile(r'["\']?([a-f0-9]{32})["\']?\s*(?:,\s*["\']?([a-zA-Z0-9]+)["\']?)?', re.IGNORECASE), "severity": "HIGH", "type": "INFURA_KEY"},
    {"name": "Alchemy API Key", "regex": re.compile(r'["\']?([a-zA-Z0-9_\-]{20,44})["\']?', re.IGNORECASE), "severity": "HIGH", "type": "ALCHEMY_KEY"},
    {"name": "Etherscan/BscScan API Key", "regex": re.compile(r'[A-Z0-9]{34}'), "severity": "HIGH", "type": "BLOCKEXPLORER_API_KEY"}, # E.g., Etherscan
    
    # Heuristics for config files (JS, TS, JSON, TOML, YAML, .env)
    {"name": "Hardhat/Truffle Config Private Key", "regex": re.compile(r'(?:privateKeys?|mnemonic)\s*:\s*\[?\s*["\'](0x[a-fA-F0-9]{64}|(?:\w+\s+){11,23}\w+)["\']', re.IGNORECASE), "severity": "CRITICAL", "type": "BUILD_TOOL_PK_MNEMONIC", "target_extensions": [".js", ".ts"]},
    {"name": "Hardhat/Truffle Config Infura/Alchemy Key", "regex": re.compile(r'(?:infuraId|alchemy|providerUrl|rpcUrls)\s*:\s*["\']?[htps:/w.]*([a-f0-9]{32}|[a-zA-Z0-9_\-]{20,44})["\']?', re.IGNORECASE), "severity": "HIGH", "type": "BUILD_TOOL_NODE_KEY", "target_extensions": [".js", ".ts"]},
    {"name": "DotEnv File (.env) content for PK", "regex": re.compile(r'^(PRIVATE_KEY|MNEMONIC|SEED_PHRASE)\s*=\s*(.*)$', re.MULTILINE | re.IGNORECASE), "severity": "CRITICAL", "type": "DOTENV_PK_MNEMONIC", "target_extensions": [".env"]},
    {"name": "DotEnv File (.env) content for API Key", "regex": re.compile(r'^(API_KEY|INFURA_ID|ALCHEMY_KEY)\s*=\s*(.*)$', re.MULTILINE | re.IGNORECASE), "severity": "HIGH", "type": "DOTENV_API_KEY", "target_extensions": [".env"]},

    {"name": "Generic API Key pattern in Scripts/Configs", "regex": re.compile(r'(api_key|api-key|apikey|API_KEY|API-KEY|APIKEY)\s*[:=]\s*["\']?([a-zA-Z0-9_\-.~+/=]{20,100})["\']?', re.IGNORECASE), "severity": "HIGH", "type": "GENERIC_API_KEY", "target_extensions": [".js", ".ts", ".py", ".json", ".yaml", ".yml", ".toml"]},
    {"name": "Database Connection String", "regex": re.compile(r'(postgres|mysql|mongodb(?:\+srv)?)://(\w+):([^@]+)@([\w.-]+)(:\d+)?/(\w+)', re.IGNORECASE), "severity": "HIGH", "type": "DB_CONN_STRING", "target_extensions": [".js", ".ts", ".py", ".json", ".yaml", ".yml", ".toml", ".env"]},

    {"name": "CI/CD Secret Variable Keyword", "regex": re.compile(r'(SECRET|PASSWORD|TOKEN|API_KEY)\s*:\s*\$\{\{.*\}\}', re.IGNORECASE), "severity": "MEDIUM", "type": "CICD_SECRET_VAR_USAGE", "target_extensions": [".yml", ".yaml"]}, # Common in GitHub Actions, GitLab CI
    {"name": "Deploy Script with 'ethers.Wallet'", "regex": re.compile(r'new\s+ethers\.Wallet\s*\(([^)]+)\)', re.IGNORECASE), "severity": "MEDIUM", "type": "ETHERS_WALLET_INIT", "target_extensions": [".js", ".ts"]},
    {"name": "Hardcoded RPC URL (non-standard)", "regex": re.compile(r'["\']https?://(?!mainnet\.infura\.io|ropsten\.infura\.io|polygon-rpc\.com|bsc-dataseed\.binance\.org)[\w.:/-]+["\']', re.IGNORECASE), "severity": "MEDIUM", "type": "HARDCODED_RPC_URL", "target_extensions": [".js", ".ts", ".py"]},
    {"name": "NPM Token in .npmrc", "regex": re.compile(r'//registry\.npmjs\.org/:_authToken=([a-zA-Z0-9-]+)'), "severity": "HIGH", "type": "NPM_TOKEN", "target_extensions": [".npmrc"]}, # File name itself is the target
    {"name": "SSH Private Key Header", "regex": re.compile(r'-----BEGIN ((RSA|DSA|EC|OPENSSH) )?PRIVATE KEY-----'), "severity": "CRITICAL", "type": "SSH_PRIVATE_KEY"}, # Applies to any text
    {"name": "JWT Token", "regex": re.compile(r'[ey][A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*'), "severity": "MEDIUM", "type": "JWT_TOKEN"}, # Applies to any text
    {"name": "TODO/FIXME/XXX Comments (General)", "regex": re.compile(r'(#|//|\*)\s*(TODO|FIXME|XXX|HACK)', re.IGNORECASE), "severity": "LOW", "type": "DEV_COMMENT_TODO_GENERAL"},
]

ALL_HEURISTICS = SOLIDITY_HEURISTICS + GENERAL_WEB3_HEURISTICS

def run_command(command_list, cwd=None, capture_output=True, text=True, check=False, timeout=None):
    print(f"Running command: {' '.join(command_list)} {'in '+cwd if cwd else ''}")
    try:
        env = os.environ.copy()
        if GITHUB_TOKEN: # if not locally setuped gh!
            env["GITHUB_TOKEN"] = GITHUB_TOKEN
        result = subprocess.run(
            command_list,
            cwd=cwd,
            capture_output=capture_output,
            text=text,
            check=check,
            env=env,
            timeout=timeout
        )
        if result.returncode != 0:
             print(f"Warning/Error: Command {' '.join(command_list)} exited with {result.returncode}")
             if result.stderr and capture_output:
                print(f"Stderr: {result.stderr.strip()}")
             if result.stdout and capture_output: # 
                 if len(result.stdout.strip()) < 500 : # fck huge outputs
                    print(f"Stdout (error context): {result.stdout.strip()}")
        return result
    except subprocess.CalledProcessError as e:
        print(f"CalledProcessError running command: {' '.join(e.cmd)}. Return code: {e.returncode}")
        if e.stderr: print(f"Stderr: {e.stderr.strip()}")
        if e.stdout and len(e.stdout.strip()) < 500 : print(f"Stdout: {e.stdout.strip()}")
        return e
    except subprocess.TimeoutExpired as e:
        print(f"Timeout running command: {' '.join(e.cmd if hasattr(e, 'cmd') else str(e))}") # e.cmd might not exist
        return e
    except Exception as e:
        print(f"General exception running command {' '.join(command_list)}: {e}")
        return None